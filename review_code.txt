#ifndef CATEGORY_H
#define CATEGORY_H
#include <string>
#include "NameTable.h"
using namespace std;
class CategoryTable : public NameTable {
public:
    CategoryTable(int size) : NameTable(size) {}
    
    void addCategory(int id, string name) {
        add(id, name);
    }
    
    string getCategoryName(int id) {
        return getName(id);
    }
};
#endif
#ifndef DATE_H
#define DATE_H

struct date
{
    int day, month, year;
};
void printDate(date d);
#endif
#ifndef EXPENSETRANSACTION_H
#define EXPENSETRANSACTION_H
#include <string>
#include <iostream>
#include "date.h"
using namespace std;
// Struct Giao dịch (Data Model)
struct ExpenseTransaction {
    date day;
    double amount;
    string description;
    int categoryID;
    int walletID;
};
// Class Mảng động
class ExpenseArray {
private:
    ExpenseTransaction* list; // Con trỏ mảng
    int capacity;            // Sức chứa
    int count;               // Số lượng hiện tại

    void resize();           // Hàm nội bộ để mở rộng bộ nhớ
public:
    ExpenseArray(int initialSize = 10);
    ~ExpenseArray();
    void addTransaction(date day, double amount, int categoryID, int walletID, string desc);
    int getCount();
    ExpenseTransaction getAt(int index);
    double getTotalExpense(); // Hàm thống kê
    void saveToFile(const string &filename);
    void loadFromFile(const string &filename);
};
#endif  
#ifndef INCOMESOURCETABLE_H
#define INCOMESOURCETABLE_H

#include <string>
#include "NameTable.h"
using namespace std;

class IncomeSourceTable : public NameTable {

public:
    IncomeSourceTable(int size) : NameTable(size) {}
    
    void insertSource(int id, string name) {
        add(id, name);
    }
    
    string getSourceName(int id) {
        return getName(id);
    }
};

#endif
#ifndef INCOME_TRANSACTION_H
#define INCOME_TRANSACTION_H

#include <string>
#include <iostream>
#include "date.h"
using namespace std;

// Struct Giao dịch (Data Model)
struct IncomeTransaction {
    date day;
    double amount;
    string description;
    int sourceID;
    int walletID;
};

// Class Mảng động
class IncomeArray {
private:
    IncomeTransaction* list; // Con trỏ mảng
    int capacity;            // Sức chứa
    int count;               // Số lượng hiện tại

    void resize();           // Hàm nội bộ để mở rộng bộ nhớ

public:
    IncomeArray(int initialSize = 10);
    ~IncomeArray();

    void addTransaction(date day, double amount, int sourceID, int walletID, string desc);
    int getCount();
    IncomeTransaction getAt(int index);
    double getTotalIncome(); // Hàm thống kê

    void saveToFile(const string &filename);
    void loadFromFile(const string &filename);
};

#endif
#ifndef NAMETABLE_H
#define NAMETABLE_H

#include <string>
#include <iostream>
#include <fstream>
using namespace std;

struct Node {
    int id;
    string name;
    Node* next;
    Node(int id, string name) : id(id), name(name), next(nullptr) {}
};

class NameTable {
protected:
    Node** table;
    int capacity;
    int hashFunction(int key);

public:
    NameTable(int size);
    virtual ~NameTable(); 

    void add(int id, string name);       
    string getName(int id);              
    void remove(int id);                 
    void saveToFile(const string &filename);
    void loadFromFile(const string &filename);
    void clear();
};

#endif
#ifndef WALLET_H
#define WALLET_H
#include <string>
#include "NameTable.h"
using namespace std;

class WalletTable : public NameTable {
public:
    WalletTable(int size) : NameTable(size) {}
    
    void addWallet(int id, string name) {
        add(id, name);
    }
    
    string getWalletName(int id) {
        return getName(id);
    }
};

#endif
#include "date.h"
#include <iostream>
using namespace std;
// Hàm in ngày tháng năm
void printDate(date d) {
    cout << (d.day < 10 ? "0" : "") << d.day << "/"
         << (d.month < 10 ? "0" : "") << d.month << "/"
         << d.year;
}
#include "ExpenseTransaction.h"
#include <fstream>
#include <iostream>
using namespace std;
ExpenseArray::ExpenseArray(int initialSize)
{
    capacity = initialSize;
    count = 0;
    list = new ExpenseTransaction[capacity];
}
ExpenseArray::~ExpenseArray()
{
    delete[] list;
}
void ExpenseArray::resize()
{
    capacity *= 2;
    ExpenseTransaction* newList = new ExpenseTransaction[capacity];
    for (int i = 0; i < count; i++)
    {
        newList[i] = list[i];
    }
    delete[] list;
    list = newList;
}
void ExpenseArray::addTransaction(date day, double amount, int categoryID, int walletID, string desc)
{
    if (count == capacity)
    {
        resize();
    }
    list[count].day = day;
    list[count].amount = amount;
    list[count].categoryID = categoryID;
    list[count].walletID = walletID;
    list[count].description = desc;
    count++;
}
int ExpenseArray::getCount()
{
    return count;
}
ExpenseTransaction ExpenseArray::getAt(int index)
{
    if (index < 0 || index >= count)
    {
        throw out_of_range("Index out of range");
    }
    return list[index];
}
double ExpenseArray::getTotalExpense()
{
    double total = 0.0;
    for (int i = 0; i < count; i++)
    {
        total += list[i].amount;
    }
    return total;
}
void ExpenseArray::saveToFile(const string &filename)
{
    ofstream fout(filename, ios::binary);
    if (!fout.is_open())
    {
        return;
    }
    fout.write(reinterpret_cast<char*>(&count), sizeof(count));
    for (int i = 0; i < count; i++)
    {
        fout.write(reinterpret_cast<char*>(&list[i].day), sizeof(date));
        fout.write(reinterpret_cast<char*>(&list[i].amount), sizeof(double));
        fout.write(reinterpret_cast<char*>(&list[i].categoryID), sizeof(int));
        fout.write(reinterpret_cast<char*>(&list[i].walletID), sizeof(int));

        int descLen = list[i].description.size();
        fout.write(reinterpret_cast<char*>(&descLen), sizeof(descLen));
        fout.write(list[i].description.c_str(), descLen);
    }
    fout.close();
}
void ExpenseArray::loadFromFile(const string &filename)
{
    ifstream fin(filename, ios::binary);
    if (!fin.is_open())
    {
        return;
    }
    fin.read(reinterpret_cast<char*>(&count), sizeof(count));
    if (count > capacity)
    {
        delete[] list;
        capacity = count;
        list = new ExpenseTransaction[capacity];
    }   
    for (int i = 0; i < count; i++)
    {
        fin.read(reinterpret_cast<char*>(&list[i].day), sizeof(date));
        fin.read(reinterpret_cast<char*>(&list[i].amount), sizeof(double));
        fin.read(reinterpret_cast<char*>(&list[i].categoryID), sizeof(int));
        fin.read(reinterpret_cast<char*>(&list[i].walletID), sizeof(int));

        int descLen;
        fin.read(reinterpret_cast<char*>(&descLen), sizeof(descLen));
        list[i].description.resize(descLen);
        fin.read(&list[i].description[0], descLen);
    }
    fin.close();
}
#include "IncomeTransaction.h"
#include <fstream>
#include <iostream>
using namespace std;
IncomeArray::IncomeArray(int initialSize)
{
    capacity = initialSize;
    count = 0;
    list = new IncomeTransaction[capacity];
}
IncomeArray::~IncomeArray()
{
    delete[] list;
}
void IncomeArray::resize()
{
    capacity *= 2;
    IncomeTransaction* newList = new IncomeTransaction[capacity];
    for (int i = 0; i < count; i++)
    {
        newList[i] = list[i];
    }
    delete[] list;
    list = newList;
}
void IncomeArray::addTransaction(date day, double amount, int sourceID, int walletID, string desc)
{
    if (count == capacity)
    {
        resize();
    }
    list[count].day = day;
    list[count].amount = amount;
    list[count].sourceID = sourceID;
    list[count].walletID = walletID;
    list[count].description = desc;
    count++;
}
int IncomeArray::getCount()
{
    return count;
}
IncomeTransaction IncomeArray::getAt(int index)
{
    if (index < 0 || index >= count)
    {
        throw out_of_range("Index out of range");
    }
    return list[index];
}
double IncomeArray::getTotalIncome()
{
    double total = 0.0;
    for (int i = 0; i < count; i++)
    {
        total += list[i].amount;
    }
    return total;
}
void IncomeArray::saveToFile(const string &filename)
{
    ofstream fout(filename, ios::binary);
    if (!fout.is_open())
    {
        cerr << "Error opening file for writing: " << filename << endl;
        return;
    }
    fout.write((char*)&count, sizeof(int));
    for (int i = 0; i < count; i++)
    {
        fout.write((char*)&list[i].day, sizeof(date));
        fout.write((char*)&list[i].amount, sizeof(double));
        fout.write((char*)&list[i].sourceID, sizeof(int));
        fout.write((char*)&list[i].walletID, sizeof(int));

        int descLen = list[i].description.size();
        fout.write((char*)&descLen, sizeof(int));
        fout.write(list[i].description.c_str(), descLen);
    }
    fout.close();
}
void IncomeArray::loadFromFile(const string &filename)
{
    ifstream fin(filename, ios::binary);
    if (!fin.is_open())
    {
        cerr << "Error opening file for reading: " << filename << endl;
        return;
    }
    fin.read((char*)&count, sizeof(int));
    if (count > capacity)
    {
        delete[] list;
        capacity = count;
        list = new IncomeTransaction[capacity];
    }
    for (int i = 0; i < count; i++)
    {
        fin.read((char*)&list[i].day, sizeof(date));
        fin.read((char*)&list[i].amount, sizeof(double));
        fin.read((char*)&list[i].sourceID, sizeof(int));
        fin.read((char*)&list[i].walletID, sizeof(int));

        int descLen;
        fin.read((char*)&descLen, sizeof(int));
        list[i].description.resize(descLen);
        fin.read(&list[i].description[0], descLen);
    }
    fin.close();
}


#include <iostream>
#include <iomanip>
#include "date.h"
#include "wallet.h"
#include "IncomeSourceTable.h"
#include "Category.h"
#include "IncomeTransaction.h"
#include "ExpenseTransaction.h"

using namespace std;

// Hàm in báo cáo tổng hợp (Kết nối tất cả các thành phần)
void printReport(IncomeArray& incomes, ExpenseArray& expenses, 
                 WalletTable& wallets, IncomeSourceTable& sources, CategoryTable& categories) {
    
    cout << "\n================ BAO CAO TAI CHINH ================\n";
    
    // 1. Hiển thị danh sách thu nhập
    cout << "\n--- DANH SACH THU NHAP ---\n";
    cout << left << setw(12) << "Ngay" 
         << left << setw(20) << "Nguon Thu" 
         << left << setw(20) << "Vi Tien" 
         << right << setw(15) << "So Tien" 
         << "   Mo ta" << endl;
    
    for (int i = 0; i < incomes.getCount(); i++) {
        IncomeTransaction t = incomes.getAt(i);
        
        // KẾT NỐI: Dùng ID để lấy Tên từ các bảng Hash Table
        string sourceName = sources.getSourceName(t.sourceID);
        string walletName = wallets.getWalletName(t.walletID);
        
        printDate(t.day);
        cout << "  " << left << setw(20) << sourceName 
             << left << setw(20) << walletName 
             << right << setw(15) << (size_t)t.amount 
             << "   " << t.description << endl;
    }

    // 2. Hiển thị danh sách chi tiêu
    cout << "\n--- DANH SACH CHI TIEU ---\n";
    cout << left << setw(12) << "Ngay" 
         << left << setw(20) << "Danh Muc" 
         << left << setw(20) << "Vi Tien" 
         << right << setw(15) << "So Tien" 
         << "   Mo ta" << endl;

    for (int i = 0; i < expenses.getCount(); i++) {
        ExpenseTransaction t = expenses.getAt(i);
        
        // KẾT NỐI: Dùng ID để lấy Tên
        string catName = categories.getCategoryName(t.categoryID);
        string walletName = wallets.getWalletName(t.walletID);

        printDate(t.day);
        cout << "  " << left << setw(20) << catName
             << left << setw(20) << walletName
             << right << setw(15) << (size_t)t.amount
             << "   " << t.description << endl;
    }

    // 3. Tổng kết
    double totalIncome = incomes.getTotalIncome();
    double totalExpense = expenses.getTotalExpense();
    cout << "\n---------------------------------------------------";
    cout << "\nTONG THU: " << (size_t)totalIncome;
    cout << "\nTONG CHI: " << (size_t)totalExpense;
    cout << "\nSO DU:    " << (size_t)(totalIncome - totalExpense) << endl;
    cout << "===================================================\n";
}

int main() {
    // Tên các file dữ liệu
    string fileWallet = "saves/wallets.dat";
    string fileSource = "saves/sources.dat";
    string fileCat = "saves/categories.dat";
    string fileInc = "saves/incomes.dat";
    string fileExp = "saves/expenses.dat";
    // --- PHẦN 1: NHẬP DỮ LIỆU MẪU ---
    cout << ">>> DANG KHOI TAO DU LIEU MAU...\n";

    // 1. Khởi tạo các bảng (Size = 10)
    WalletTable wallets(10);
    IncomeSourceTable sources(10);
    CategoryTable categories(10);
    IncomeArray incomes;
    ExpenseArray expenses;

    // 2. Thêm dữ liệu danh mục (Master Data)
    wallets.addWallet(1, "Vi Tien Mat");
    wallets.addWallet(2, "Tai Khoan Techcom");

    sources.insertSource(101, "Luong Thang 12");
    sources.insertSource(102, "Thuong Tet");

    categories.addCategory(201, "An Uong");
    categories.addCategory(202, "Di Chuyen");

    // 3. Thêm giao dịch (Transaction Data)
    // Thu nhập: Lương về ví Techcom
    incomes.addTransaction({15, 12, 2024}, 20000000, 101, 2, "Nhan luong thang 12");
    // Chi tiêu: Ăn trưa bằng tiền mặt
    expenses.addTransaction({16, 12, 2024}, 50000, 201, 1, "Com tam Cali");
    // Chi tiêu: Đổ xăng bằng tiền mặt
    expenses.addTransaction({17, 12, 2024}, 100000, 202, 1, "Do xang xe may");

    // 4. In thử dữ liệu trong RAM
    cout << ">>> DU LIEU TRUOC KHI LUU FILE:\n";
    printReport(incomes, expenses, wallets, sources, categories);


    // --- PHẦN 2: KIỂM TRA LƯU FILE ---
    cout << "\n>>> DANG LUU DU LIEU VAO FILE...\n";
    wallets.saveToFile(fileWallet);
    sources.saveToFile(fileSource);
    categories.saveToFile(fileCat);
    incomes.saveToFile(fileInc);
    expenses.saveToFile(fileExp);
    cout << ">>> DA LUU THANH CONG!\n";


    // --- PHẦN 3: KIỂM TRA ĐỌC FILE (Dữ liệu mới hoàn toàn) ---
    cout << "\n>>> DANG TAI DU LIEU TU FILE LEN CAC DOI TUONG MOI...\n";
    
    // Tạo các đối tượng mới hoàn toàn để đảm bảo không dùng lại dữ liệu cũ trong RAM
    WalletTable newWallets(10);
    IncomeSourceTable newSources(10);
    CategoryTable newCategories(10);
    IncomeArray newIncomes;
    ExpenseArray newExpenses;

    newWallets.loadFromFile(fileWallet);
    newSources.loadFromFile(fileSource);
    newCategories.loadFromFile(fileCat);
    newIncomes.loadFromFile(fileInc);
    newExpenses.loadFromFile(fileExp);

    cout << ">>> DU LIEU SAU KHI DOC TU FILE:\n";
    printReport(newIncomes, newExpenses, newWallets, newSources, newCategories);

    return 0;
}
#include "NameTable.h"
#include <iostream>
#include <fstream>
using namespace std;

NameTable::NameTable(int size)
{
    this->capacity = size;

    table = new Node *[capacity];

    for (int i = 0; i < capacity; i++)
    {
        table[i] = nullptr;
    }
}
NameTable::~NameTable()
{
    clear();
    delete[] table;
}
int NameTable::hashFunction(int key){
    return key % NameTable::capacity;
}
void NameTable::add(int id, string name)
{
    int index = hashFunction(id);
    Node *current = table[index];
    while (current != nullptr)
    {
        if (current->id == id)
        {
            current->name = name;
            return;
        }
        current = current->next;
    }

    Node *newNode = new Node(id, name);
    newNode->next = table[index];
    table[index] = newNode;
}
string NameTable::getName(int id)
{
    int index = hashFunction(id);
    Node *current = table[index];
    while (current != nullptr)
    {
        if (current->id == id)
            return current->name;
        current = current->next;
    }
    return "Unknown";
}
void NameTable::remove(int id){
    int index = hashFunction(id);
    Node* current = table[index];
    Node* prev = nullptr;

    while (current != nullptr) {
        if (current->id == id) {
            if (prev == nullptr) {
                table[index] = current->next;
            } else {
                prev->next = current->next;
            }
            delete current;
            return;
        }
        prev = current;
        current = current->next;
    }
}
void NameTable::saveToFile(const string &filename) {
    ofstream fout(filename, ios::binary | ios::trunc);
    if (!fout.is_open()) {
        return;
    }   
    int count = 0;
    for (int i = 0; i < capacity; i++) {
        Node* cur = table[i];
        while (cur) {
            count++;
            cur = cur->next;
        }
    }
    fout.write((char*)&count, sizeof(int));
    for (int i = 0; i < capacity; i++) {
        Node* cur = table[i];
        while (cur) {
            int id = cur->id;
            int nameLen = (int)cur->name.size();
            fout.write((char*)&id, sizeof(int));
            fout.write((char*)&nameLen, sizeof(int));
            fout.write(cur->name.c_str(), nameLen);
            cur = cur->next;
        }
    }
    fout.close();
}
void NameTable::loadFromFile(const string &filename) {
    ifstream fin(filename, ios::binary);
    if (!fin.is_open()) {
        return;
    }   
    clear();
    int count = 0;  
    fin.read((char*)&count, sizeof(int));
    for (int i = 0; i < count; i++) {
        int id;
        int nameLen;
        fin.read((char*)&id, sizeof(int));
        fin.read((char*)&nameLen, sizeof(int));
        string name(nameLen, '\0');
        fin.read(&name[0], nameLen);
        add(id, name);
    }
    fin.close();
}
void NameTable::clear() {
    for (int i = 0; i < capacity; i++) {
        Node* cur = table[i];
        while (cur != nullptr) {
            Node* next = cur->next;
            delete cur;
            cur = next;
        }
        table[i] = nullptr;
    }
}

